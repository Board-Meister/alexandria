"use strict";(self.webpackChunktest=self.webpackChunktest||[]).push([[1882],{8320:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"dullahan/architecture","title":"Architecture","description":"Dullahan modules are developed in Event-driven development following Event Core rules. Event Core is a term created to","source":"@site/docs/dullahan/architecture.md","sourceDirName":"dullahan","slug":"/dullahan/architecture","permalink":"/docs/dullahan/architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/Board-Meister/alexandria/blob/master/docs/dullahan/architecture.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"sidebar_label":"Architecture"},"sidebar":"tutorialSidebar","previous":{"title":"Events","permalink":"/docs/dullahan/events"},"next":{"title":"User Bundle","permalink":"/docs/category/user-bundle"}}');var r=t(4848),i=t(8453);const s={sidebar_position:4,sidebar_label:"Architecture"},o="Architecture",l={},c=[{value:"Event Core",id:"event-core",level:2},{value:"Default behavior implementation",id:"default-behavior-implementation",level:2},{value:"Framework-agnostic",id:"framework-agnostic",level:2},{value:"Events in layered architecture",id:"events-in-layered-architecture",level:2},{value:"Functor",id:"functor",level:2}];function d(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"architecture",children:"Architecture"})}),"\n",(0,r.jsx)(n.p,{children:'Dullahan modules are developed in Event-driven development following Event Core rules. Event Core is a term created to\nhelp describe an approach for creating manageable modules in EDD. The name derives from Eric Evans DDD "Abstract Core",\nas they share the same concept - to define a way/implementation details. The difference between Abstract and Event Core\nis that Abstract Core imposes functionality to be implemented and Event Core defines behavior that has to handled.\nAdditionally, default handlers can be and/or prevented/replaced/extended, making it a great pattern for creating\nframeworks.'}),"\n",(0,r.jsx)(n.h2,{id:"event-core",children:"Event Core"}),"\n",(0,r.jsx)(n.p,{children:"Unlike Abstract Core being made of only interfaces, Event Core is not only made from possible events, processes and sagas. It is possible to define default behavior for each process making it easier to implement but still allowing for high level of customization."}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Any and all actions must happen on the event call."}),"\n",(0,r.jsx)(n.li,{children:"Each Saga and Event have separate calls."}),"\n",(0,r.jsx)(n.li,{children:"Sagas and Events default action should be preventable."}),"\n",(0,r.jsx)(n.li,{children:"Sagas are made of Events."}),"\n",(0,r.jsx)(n.li,{children:"Getting and Setting must be a separate Event."}),"\n",(0,r.jsx)(n.li,{children:"Sagas contain mutable Request and Response (in a I/O manner) which are accessible by the Events."}),"\n",(0,r.jsx)(n.li,{children:"Top level Events are called Processes and should work as Unit of Work."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"default-behavior-implementation",children:"Default behavior implementation"}),"\n",(0,r.jsxs)(n.p,{children:["There are events that implement default behavior, one that can be replaced. Each of those event implement ",(0,r.jsx)(n.code,{children:"PreventableEventInterface"})," which defines two methods:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",metastring:'title="preventDefault()"',children:"/**\n * Sets event prevention flag to true\n *\n * Warning: settings this after default action does nothing!\n * Be sure to call it before the default!\n */\npublic function preventDefault(): void;\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",metastring:'title="wasDefaultPrevented()"',children:"/**\n * Returns logical value defining if default was prevented\n */\npublic function wasDefaultPrevented(): bool;\n"})}),"\n",(0,r.jsx)(n.p,{children:"Each event implementing this interface should have default action provided by the module. Some events are not preventable due to not having default actions or being unpreventable."}),"\n",(0,r.jsx)(n.h2,{id:"framework-agnostic",children:"Framework-agnostic"}),"\n",(0,r.jsxs)(n.p,{children:["One of the Dullahan principals is not to be framework specific and be more of behavior definition then actual implementation. Although, modules present ready to use implementation it's more of a body (functionality) without a head (business). Some of them even lack implementation of the interfaces they use (like ",(0,r.jsx)(n.code,{children:"EventDispatcherInterface"}),") which must be defined after choosing which framework you want to use."]}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsx)(n.p,{children:"Currently all Dullahan modules natively support only Symfony framework"})}),"\n",(0,r.jsx)(n.p,{children:"Currently recommended way of creating framework-agnostic modules is to have at least 2 separate repositories: one with the module specific functionality and another working as a bridge between module and framework. With time you could create another bridges for another frameworks."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"dullahan/\n - user/\n - user-bridge-symfony/\n - user-bridge-laravel/\n - user-bridge-codeigniter/\n"})}),"\n",(0,r.jsxs)(n.p,{children:["What architecture you choose inside the bridge package is up to the framework, you should follow the recommended architecture. But inside the main package it is recommended to use a variant of the Ports & Adapters architecture with DDD layers (where our adapters are in different package ",":D",")."]}),"\n",(0,r.jsx)(n.p,{children:"This means that you have your normal DDD layers:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"dullahan/\n - user/\n - - Presentation/\n - - Application/\n - - Domain/\n - - Infrastructure/\n"})}),"\n",(0,r.jsxs)(n.p,{children:["And additionally add ",(0,r.jsx)(n.code,{children:"Port"})," folder for placing interfaces you will be implementing in your bridges or your user will DI:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"dullahan/\n - user/\n - - Presentation/\n - - Application/\n - - Domain/\n - - Infrastructure/\n - - Port/\n - - - Presentation/\n - - - Application/\n - - - Domain/\n - - - Infrastructure/\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Interfaces in ",(0,r.jsx)(n.code,{children:"Port"})," folder shouldn't be nested to avoid issues such as trying to recreate paths during implementation in the bridges which leads to breaking recommended architectures. It is easier for developer and user when there is no complex and highly nested path to the interface you want to implement."]}),"\n",(0,r.jsx)(n.h2,{id:"events-in-layered-architecture",children:"Events in layered architecture"}),"\n",(0,r.jsx)(n.p,{children:"Events listeners/subscribers similarly to Commands and Controllers go to the Presentation layer. Our implementation makes it an another way to interact with the app resources. But event implementation goes to the Domain layer and are actually handled by the Facades inside Application layer (although they have to be firstly caught be the Listeners)."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-none",metastring:'title="Example of implementing Register user Saga in the User module"',children:"dullahan/\n - user/\n - - Presentation/\n - - - Event/\n - - - - Transport/\n           // All implement PreventableEventInterface\n - - - - - RegisterUserSaga.php\n - - - - - CreateUserProcess.php\n - - - - - ValidateRegistrationProcess.php\n - - - - Listener/\n           // Uses UserManagerFacade by requesting UserPersistManagerInterface\n - - - - - RegisterUserListener.php\n - - Application/\n       // implements UserPersistManagerInterface, UserRetrievalManagerInterface, UserSerializerInterface\n - - - UserManagerFacade.php\n - - Domain/\n - - - RegisteringUser.php\n - - - User.php\n - - - UserPersistManager.php\n - - - UserRetrievalManager.php\n - - - UserSerializer.php\n - - Infrastructure/\n - - - UserRepository.php\n - - Port/\n - - - Application/\n - - - - UserPersistManagerInterface.php\n - - - - UserRetrievalManagerInterface.php\n - - - - UserSerializerInterface.php\n"})}),"\n",(0,r.jsxs)(n.p,{children:["With this implementation we give our users few options for customization and are following SOLID/Tactical Design rules. It allows for polymorphic DI or for setting your own listener for additional functionality like validation (like 2FA or reCaptcha). Additionally you could set listener before ",(0,r.jsx)(n.code,{children:"CreateUserProcess"})," to change/add more details to registration payload before user is created or after if you want to do something with created user like send an activation email."]}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsx)(n.p,{children:"This example is not framework-agnostic, in that approach you would have your Listeners inside the bridge package and probably have additional abstraction for the repositories or just depend on the Domain services implementation and DI."})}),"\n",(0,r.jsx)(n.h2,{id:"functor",children:"Functor"}),"\n",(0,r.jsx)(n.p,{children:"Functor is a Function object known under other names like invoker. It is basically a class that can be called and shouldn't implement other public methods then one use for invocation. Basically it makes is a Command for implementing Command Pattern. But we avoid using Command key world as it is already taken for the console command classes - hence the Functor."}),"\n",(0,r.jsx)(n.p,{children:"This approach can result in a huge Facade class which DI tens of classes and is very heavy. To make it easier for our containers and ease the coupling between objects it a good idea to create specialized classes/commands/invokers only for one use case. Thanks to that you can easily separate responsibilities and make your module/package more behavior based."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",metastring:'title="Get entity repository functor example"',children:"use Dullahan\\Entity\\Port\\Interface\\EntityRepositoryInterface;\nuse Dullahan\\Entity\\Presentation\\Event\\Transport\\GetEntityRepository;\nuse Dullahan\\Main\\Contract\\DatabaseActionsInterface;\n\n/**\n * @template T of object\n */\nclass RetrieveEntityRepositoryFunctor\n{\n    public function __construct(\n        protected DatabaseActionsInterface $databaseConnection,\n    ) {\n    }\n\n    /**\n     * @param GetEntityRepository<T> $event\n     *\n     * @return EntityRepositoryInterface<T>|null\n     */\n    public function __invoke(GetEntityRepository $event): ?EntityRepositoryInterface\n    {\n        $class = $event->class;\n        if (!class_exists($class)) {\n            return null;\n        }\n\n        return $this->databaseConnection->getRepository($class);\n    }\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var a=t(6540);const r={},i=a.createContext(r);function s(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);