"use strict";(self.webpackChunktest=self.webpackChunktest||[]).push([[7913],{6990:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>g,frontMatter:()=>r,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"marshal/tags","title":"Tagging plugins","description":"In you registration you can tag a plugin. By tagging I means assigning specific labels by which they can","source":"@site/docs/marshal/tags.md","sourceDirName":"marshal","slug":"/marshal/tags","permalink":"/docs/marshal/tags","draft":false,"unlisted":false,"editUrl":"https://github.com/Board-Meister/alexandria/blob/master/docs/marshal/tags.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6,"sidebar_label":"Tagging plugins"},"sidebar":"tutorialSidebar","previous":{"title":"Loading resources","permalink":"/docs/marshal/loading-resources"},"next":{"title":"Registration cheat sheet","permalink":"/docs/marshal/registration"}}');var t=s(4848),a=s(8453);const r={sidebar_position:6,sidebar_label:"Tagging plugins"},l="Tagging plugins",c={},o=[{value:"How to tag a plugin",id:"how-to-tag-a-plugin",level:2},{value:"Retrieved tagged plugins",id:"retrieved-tagged-plugins",level:2},{value:"How are plugins passed",id:"how-are-plugins-passed",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"tagging-plugins",children:"Tagging plugins"})}),"\n",(0,t.jsx)(n.p,{children:"In you registration you can tag a plugin. By tagging I means assigning specific labels by which they can\nbe later retrieved."}),"\n",(0,t.jsx)(n.h2,{id:"how-to-tag-a-plugin",children:"How to tag a plugin"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"marshal.register({\n    entry: {\n        // ...\n        namespace: 'boardmeister',\n        name: 'router',\n    },\n    tags: ['subscriber'],\n})\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In the example above we have tagged ",(0,t.jsx)(n.code,{children:"boardmeister/router"})," as a ",(0,t.jsx)(n.code,{children:"subscriber"}),". By itself it doesn't really mean anything.\nBut when we combine it with a specific event related plugin (",(0,t.jsx)(n.a,{href:"/docs/herald/",children:"Herald"}),") you've just extended\navailable functionality of this plugin significantly."]}),"\n",(0,t.jsx)(n.h2,{id:"retrieved-tagged-plugins",children:"Retrieved tagged plugins"}),"\n",(0,t.jsxs)(n.p,{children:["To retrieve tagged plugins we are using ",(0,t.jsx)(n.code,{children:"requires"})," parameter but in a specific way:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"marshal.register({\n    entry: {\n        // ...\n        namespace: 'boardmeister',\n        name: 'herald',\n    },\n    requires: ['!subscriber']\n})\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The exclamation mark ",(0,t.jsx)(n.code,{children:"!"})," tells Marshal that everything after it, is a tag name. Now Marshal will gather all tagged\nplugins and pass them as an array into Herald:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="herald.conf.ts"',children:"import type { Module } from '@boardmeister/marshal';\nimport type { ISubscriber } from '@src/type.d';\n\nexport interface IInjected {\n  subscribers: { config: ISubscriber, module: Module }[];\n}\n\nclass Herald {\n  #injected: IInjected = {\n    subscribers: []\n  };\n\n  static inject: Record<string, string> = {\n    subscribers: '!subscriber',\n  }\n  inject(injections: IInjected): void {\n    this.#injected = injections;\n  }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Now we are able to automatically register all tagged plugins and read to what events they are subscribing to. In\nthe same way we can create automatic way to register new routes into router, retrieve menu elements, register logger\nchannels etc."}),"\n",(0,t.jsx)(n.h2,{id:"how-are-plugins-passed",children:"How are plugins passed"}),"\n",(0,t.jsx)(n.p,{children:"Plugins in the array are not just instances of the plugins. They consist of plugin definition and their instances."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"config"})," - Config parameter holds related plugin registration"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"module"})," - holds tagged plugin instance and later (after it was initialized) the initialized state"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"static inject: Record<string, string> = {\n    subscribers: '!subscriber',\n}\ninject(injections: IInjected): void {\n    this.#injected = injections;\n    this.#injected.subscribers.forEach(subscriber => {\n        console.log(subscriber.config, subscriber.module);\n    });\n}\n"})})]})}function g(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>l});var i=s(6540);const t={},a=i.createContext(t);function r(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);