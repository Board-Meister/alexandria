"use strict";(self.webpackChunktest=self.webpackChunktest||[]).push([[8722],{7464:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"dullahan/entity/serialization_caching","title":"Serialization & Caching","description":"It is important to have adequate serialization technics when sending data across the wire. All API End Points use the","source":"@site/docs/dullahan/entity/serialization_caching.md","sourceDirName":"dullahan/entity","slug":"/dullahan/entity/serialization_caching","permalink":"/docs/dullahan/entity/serialization_caching","draft":false,"unlisted":false,"editUrl":"https://github.com/Board-Meister/alexandria/blob/master/docs/dullahan/entity/serialization_caching.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7,"sidebar_label":"Serialization & Caching"},"sidebar":"tutorialSidebar","previous":{"title":"Manage interfaces","permalink":"/docs/dullahan/entity/programatically_manage"}}');var a=t(4848),r=t(8453);const o={sidebar_position:7,sidebar_label:"Serialization & Caching"},s="Serialization & Caching",l={},c=[{value:"Manage serialization handles",id:"manage-serialization-handles",level:2},{value:"Create custom normalizer",id:"create-custom-normalizer",level:3},{value:"Handling entity caching",id:"handling-entity-caching",level:2},{value:"Retrieving cached entity",id:"retrieving-cached-entity",level:2},{value:"Cache hydration",id:"cache-hydration",level:2},{value:"Advanced topis - relation annotation structure",id:"advanced-topis---relation-annotation-structure",level:2},{value:"Cache key",id:"cache-key",level:3},{value:"Cache object",id:"cache-object",level:3}];function h(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"serialization--caching",children:"Serialization & Caching"})}),"\n",(0,a.jsx)(n.p,{children:"It is important to have adequate serialization technics when sending data across the wire. All API End Points use the\nsame serialization mechanisms to return you data in JSON format without asking you to define serialization for each\nof your entities."}),"\n",(0,a.jsx)(n.p,{children:"And together with caching we can achieve quite the performance when it comes to retrieving data. But caching becomes\ndifficult when we take into account updates on specific entities which might have relations to other objects and\ntherefore are cached together with them. To accommodate this update we would have to clear any cache with relation to\nthis entity which is suboptimal."}),"\n",(0,a.jsx)(n.p,{children:"With that in mind we have implemented three step process for serialization & caching:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"serialize scalar data"}),"\n",(0,a.jsx)(n.li,{children:"cache serialized data"}),"\n",(0,a.jsx)(n.li,{children:"hydrate data with relations on cache retrieval"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"We only save simple types in one key-value par with annotation about entity relations. This way\nwe can easily replace old result without worrying about the relationships and still retrieve the updated entity without\nhaving to change anything in other key-value pairs."}),"\n",(0,a.jsx)(n.h2,{id:"manage-serialization-handles",children:"Manage serialization handles"}),"\n",(0,a.jsxs)(n.p,{children:["If your data type requires custom serialization methods it is possible to register your own method or serialization via\n",(0,a.jsx)(n.code,{children:"RegisterEntityNormalizer"})," event:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-php",children:"class EntitySerializerListener {\n     public function onRegisterEntityNormalizer(RegisterEntityNormalizer $event): void\n    {\n        $event->register($customNormalizerLast);                // Registers as the last normalizer\n        $event->register($customNormalizerSpecific, 10);        // Registers at the specific order\n        $event->register($customNormalizerSpecificFloat, 10.1); // Registration method also accepts floats\n    }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Registered normalizers are called upon in ascending order (1 => 2 => 3) and each value goes through each normalizer.\nWhich means that order is important if your value can handle multiple serializers."}),"\n",(0,a.jsxs)(n.p,{children:["For this reason there is an option to remove already registered normalizer with ",(0,a.jsx)(n.code,{children:"unregister"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-php",children:"class EntitySerializerListener {\n     public function onRegisterEntityNormalizer(RegisterEntityNormalizer $event): void\n    {\n        // ...\n        $event->unregister(NormalizerToReplace::class);\n    }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"This will result in script finding this normalizer and removing it from registration making it very easily to\nsupplement your own methods for serialization."}),"\n",(0,a.jsx)(n.h3,{id:"create-custom-normalizer",children:"Create custom normalizer"}),"\n",(0,a.jsxs)(n.p,{children:["To create custom normalizer you have to implement ",(0,a.jsx)(n.code,{children:"NormalizerInterface"})," and register it at ",(0,a.jsx)(n.code,{children:"RegisterEntityNormalizer"}),"\nevent as mentioned before:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-php",children:"use Dullahan\\Entity\\Port\\Domain\\NormalizerInterface;\n\nclass CustomNormalizer implements NormalizerInterface\n{\n    public function normalize(\n        string $fieldName,\n        mixed $value,\n        array $definition,\n        object $entity,\n        Context $context,\n    ): mixed {\n        return $this->normalizeCustomValue($value);\n    }\n\n    public function canNormalize(\n        string $fieldName,\n        mixed $value,\n        array $definition,\n        object $entity,\n        Context $context,\n    ): bool {\n        return 'custom' === $definition['type'];\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"handling-entity-caching",children:"Handling entity caching"}),"\n",(0,a.jsxs)(n.p,{children:["Entity related information are cached during ",(0,a.jsx)(n.code,{children:"CacheEntity"})," event which accepts the cache key, cache value and expire time.\nIf you want to change caching duration or under what key they are cached, register your listener\nbefore this event and change those options. You could event decide expiry time per entity, or make cache depended on\nthe logged user if you wished for:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-php",children:"class EntityCacheListener {\n     public function onCacheEntity(CacheEntity $event): void\n    {\n        $event->expiry = DateInterval::createFromDateString('1 day');\n        $event->expiry = 60 * 60 * 24;\n        $event->expiry = null; // If should never expire if there is not default expiry time set\n\n        $event->key .= $this->getUser()->getId(); // Mark each key with current user ID\n\n        if ($event->entity instanceof Foo) {\n            $event->expiry = 60;\n        }\n    }\n}\n"})}),"\n",(0,a.jsx)(n.admonition,{title:"Not only serialization",type:"warning",children:(0,a.jsxs)(n.p,{children:["During ",(0,a.jsx)(n.code,{children:"CacheEntity"})," we are not only caching serialized entities but also any Entity related information like\ndefinitions. ",(0,a.jsx)(n.code,{children:"CacheEntity"})," event has property which defines the purpose of the current dispatch under the name ",(0,a.jsx)(n.code,{children:"case"}),".\nAll default cases of entity serialization are defined in ",(0,a.jsx)(n.code,{children:"EntityCacheCaseEnum"}),"."]})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-php",children:'use Dullahan\\Entity\\Domain\\Enum\\EntityCacheCaseEnum;\n\nclass EntityCacheListener {\n     public function onCacheEntity(CacheEntity $event): void\n    {\n        if ($event->case === EntityCacheCaseEnum::DEFINITION->value) {\n            echo "We are caching entity definition!"\n        } else if ($event->case === EntityCacheCaseEnum::SERIALIZATION->value) {\n            echo "We are caching serialized entity!"\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"retrieving-cached-entity",children:"Retrieving cached entity"}),"\n",(0,a.jsxs)(n.p,{children:["Cached entity retrieval happens on the ",(0,a.jsx)(n.code,{children:"GetEntityCache"}),". The only notable information about this process is the ",(0,a.jsx)(n.code,{children:"cast"}),"\nproperty which defines in what format found data will be returned."]}),"\n",(0,a.jsxs)(n.p,{children:["Default implementation handles all format available in the ",(0,a.jsx)(n.code,{children:"EntityCacheCastEnum"})," enum. If you wish to expand this list\nyou will need to setup ",(0,a.jsx)("u",{children:"after"})," the event, when the cache is retrieved and you could try to cast it to requited\nformat."]}),"\n",(0,a.jsx)(n.h2,{id:"cache-hydration",children:"Cache hydration"}),"\n",(0,a.jsx)(n.p,{children:"After serialized entity was retrieved it goes through a process of hydrating it which essentially resolves to\nloading relation if requested in Data Set. No additional entities are loaded if they were not mentioned in Data Set\nparameter."}),"\n",(0,a.jsxs)(n.p,{children:["This process happens during ",(0,a.jsx)(n.code,{children:"StripSerializedEntity"})," event, which removes not requested/loads not present fields\n(mostly relations)."]}),"\n",(0,a.jsx)(n.admonition,{title:"Not extendable at the moment",type:"warning",children:(0,a.jsxs)(n.p,{children:["Currently this process is not easily extendable. The only option you have to set your script after it was called and\nmanaged data present in ",(0,a.jsx)(n.code,{children:"serialized"})," property."]})}),"\n",(0,a.jsx)(n.h2,{id:"advanced-topis---relation-annotation-structure",children:"Advanced topis - relation annotation structure"}),"\n",(0,a.jsx)(n.p,{children:"Here is an example of cached entity with two different relation annotations:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'\n{\n    "id": 1,\n    "name": "Main",\n    "barCollection": {\n        "__cached": {\n            "fieldAttr": {\n                "relation": "Doctrine\\\\ORM\\\\Mapping\\\\ManyToMany",\n                "important": [],\n                "order": null,\n                "limit": null,\n                "type": null,\n                "auto": null,\n                "plural": null,\n                "enum": null,\n                "hint": "App\\\\Entity\\\\Bar"\n            },\n            "field": "barCollection",\n            "entity": "App\\\\Entity\\\\Foo",\n            "id": 1\n        }\n    },\n    "userData": {\n        "__cached": "main:class:Dullahan-User-Domain-Entity-UserData:1:1"\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"cache-key",children:"Cache key"}),"\n",(0,a.jsxs)(n.p,{children:["If in the ",(0,a.jsx)(n.code,{children:"__cached"})," property we have simple string it means that this is OneToOne or ManyToOne relation and the string\nis just a cache key to retrieve serialized entity."]}),"\n",(0,a.jsx)(n.h3,{id:"cache-object",children:"Cache object"}),"\n",(0,a.jsxs)(n.p,{children:["If in the ",(0,a.jsx)(n.code,{children:"__cached"})," property we find object it represents ManyToMany ot OneToMany relation where we will be retrieving\na collection of related entities."]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"fieldAttr"})," property is just a representation of ",(0,a.jsx)(n.code,{children:"Dullahan\\Field"})," attribute that each property managable by Dullahan\nhas defined in the JSON form."]})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>s});var i=t(6540);const a={},r=i.createContext(a);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);